import fs from 'node:fs';
import path from 'node:path';

const ROOT = process.cwd();
const OPENMOJI_DATA_PATH = path.join(ROOT, 'node_modules', 'openmoji', 'data', 'openmoji.json');
const OPENMOJI_COLOR_SVG_DIR = path.join(ROOT, 'node_modules', 'openmoji', 'color', 'svg');
const OUTPUT_PATH = path.join(ROOT, 'src', 'lib', 'utils', 'openmoji-avatar-map.ts');

const GROUP_QUOTAS = [
	{ group: 'animals-nature', count: 40 },
	{ group: 'food-drink', count: 24 },
	{ group: 'activities', count: 16 },
	{ group: 'travel-places', count: 24 },
	{ group: 'objects', count: 24 }
];

const TARGET_ICON_COUNT = GROUP_QUOTAS.reduce((total, entry) => total + entry.count, 0);
const HEXCODE_PATTERN = /^[0-9A-F]+$/;

const rawData = fs.readFileSync(OPENMOJI_DATA_PATH, 'utf8');
/** @type {Array<{emoji: string; hexcode: string; group: string; skintone: string}>} */
const openMojiRows = JSON.parse(rawData);

/** @type {Map<string, Array<{emoji: string; hexcode: string; svgPath: string}>>} */
const candidatesByGroup = new Map(GROUP_QUOTAS.map((quota) => [quota.group, []]));

for (const row of openMojiRows) {
	if (row.skintone) continue;
	if (!HEXCODE_PATTERN.test(row.hexcode)) continue;
	if (!candidatesByGroup.has(row.group)) continue;

	const svgPath = path.join(OPENMOJI_COLOR_SVG_DIR, `${row.hexcode}.svg`);
	if (!fs.existsSync(svgPath)) continue;

	candidatesByGroup.get(row.group)?.push({
		emoji: row.emoji,
		hexcode: row.hexcode,
		svgPath
	});
}

/** @type {Array<{emoji: string; hexcode: string; svgPath: string}>} */
const selectedIcons = [];
const selectedEmoji = new Set();

for (const { group, count } of GROUP_QUOTAS) {
	const options = candidatesByGroup.get(group) ?? [];
	let taken = 0;

	for (const option of options) {
		if (taken >= count) break;
		if (selectedEmoji.has(option.emoji)) continue;
		selectedIcons.push(option);
		selectedEmoji.add(option.emoji);
		taken += 1;
	}
}

if (selectedIcons.length < TARGET_ICON_COUNT) {
	for (const { group } of GROUP_QUOTAS) {
		const options = candidatesByGroup.get(group) ?? [];
		for (const option of options) {
			if (selectedIcons.length >= TARGET_ICON_COUNT) break;
			if (selectedEmoji.has(option.emoji)) continue;
			selectedIcons.push(option);
			selectedEmoji.add(option.emoji);
		}
	}
}

if (selectedIcons.length < TARGET_ICON_COUNT) {
	throw new Error(
		`Unable to select ${TARGET_ICON_COUNT} OpenMoji icons. Found ${selectedIcons.length} valid entries.`
	);
}

function extractInnerSvg(svgSource) {
	const withoutXmlDeclaration = svgSource.replace(/<\?xml[\s\S]*?\?>\s*/i, '').trim();
	const openTagEnd = withoutXmlDeclaration.indexOf('>');
	const closeTagStart = withoutXmlDeclaration.lastIndexOf('</svg>');
	if (openTagEnd < 0 || closeTagStart < 0) {
		throw new Error('Malformed SVG. Missing root <svg> wrapper.');
	}

	return withoutXmlDeclaration
		.slice(openTagEnd + 1, closeTagStart)
		.replace(/>\s+</g, '><')
		.replace(/\s{2,}/g, ' ')
		.trim();
}

const emojiList = selectedIcons.map((entry) => entry.emoji);
const innerSvgByEmoji = {};

for (const entry of selectedIcons) {
	const rawSvg = fs.readFileSync(entry.svgPath, 'utf8');
	innerSvgByEmoji[entry.emoji] = extractInnerSvg(rawSvg);
}

const generatedModule = `/* eslint-disable */
/*
 * Generated by scripts/generate-openmoji-avatar-map.mjs.
 * Source: node_modules/openmoji/color/svg from the OpenMoji project.
 * License: CC BY-SA 4.0 (https://openmoji.org/license/).
 */

export const OPENMOJI_AVATAR_EMOJI = ${JSON.stringify(emojiList)} as const;

const OPENMOJI_INNER_SVG_BY_EMOJI: Readonly<Record<string, string>> = ${JSON.stringify(
	innerSvgByEmoji,
	null,
	'\t'
)};

export function openMojiInnerSvgForEmoji(emoji: string): string | null {
	return OPENMOJI_INNER_SVG_BY_EMOJI[emoji] ?? null;
}
`;

fs.writeFileSync(OUTPUT_PATH, generatedModule, 'utf8');
console.log(`Wrote ${selectedIcons.length} OpenMoji icons to ${OUTPUT_PATH}`);
